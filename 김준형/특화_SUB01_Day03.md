# HTTP

---

# 인터넷 프로토콜 스택의 4 계층

1. **애플리케이션 계층** - HTTP, FTP, SMTP 등 응용 프로그램 간 데이터를 주고받는 계층
2. **전송 계층** - TCP, UDP를 사용하여 애플리케이션 계층의 데이터를 패킷 단위로 전달하고 신뢰성을 보장하는 역할
3. **인터넷 계층** - IP, ICMP, ARP 등을 사용하여 패킷을 목적지까지 전달하는 역할을 수행
4. **네트워크 인터페이스 계층** - 실제 데이터를 네트워크(유선, 무선)를 통해 전송하는 역할

---

# IP (IP 프로토콜)

### IP 패킷이란?

IP 프로토콜을 통해 전달되는 데이터 단위. 출발지 IP 주소, 목적지 IP 주소, 데이터 등이 포함됨

### IP 프로토콜의 한계 (크게 3가지)

1. **비연결성** - 패킷을 보낼 때마다 연결을 새로 설정하며, 데이터 전송 전에 상대가 온라인 상태인지 확인하지 않음
2. **비신뢰성** - 패킷이 손실될 수 있으며, 순서대로 도착한다는 보장이 없음
3. **패킷 단위 전송** - 패킷 단위로 데이터를 나누어 전송하기 때문에, 큰 데이터를 보내더라도 조각나서 전달됨

---

# TCP (Transmission Control Protocol)

### TCP 세그먼트란?

TCP에서 데이터를 송신할 때 사용하는 기본 단위. 헤더와 데이터로 구성되며, 헤더에는 포트 번호, 시퀀스 번호, 체크섬 등의 정보가 포함됨

### TCP 특징 (크게 3가지)

1. **신뢰성 보장** - 데이터가 유실되지 않도록 보장하며, 순서대로 전달됨
2. **흐름 제어** - 송신자가 수신자의 처리 속도를 고려하여 데이터를 조절함
3. **혼잡 제어** - 네트워크의 혼잡도를 고려하여 패킷 전송 속도를 조절함

### 3 Way Handshake

TCP에서 신뢰성을 보장하기 위해 연결을 설정하는 과정

1. 클라이언트 → 서버 : **SYN** (연결 요청)
2. 서버 → 클라이언트 : **SYN + ACK** (연결 요청 수락 및 응답)
3. 클라이언트 → 서버 : **ACK** (연결 요청 확인)

---

# UDP (User Datagram Protocol)

### UDP가 최적화하기에 좋은 이유?

1. **비연결성** - 연결을 설정하지 않아 오버헤드가 적음
2. **빠른 속도** - TCP보다 속도가 빠르며, 실시간 데이터 전송에 유리함
3. **단순한 구조** - 패킷 헤더가 단순하여 데이터 처리가 빠름

UDP는 실시간 스트리밍, 온라인 게임, VoIP 등에 적합함

---

# PORT

### IP는 하나인데 여러 개의 서버와 통신해야 할 때 어떻게 할까?

포트를 사용하여 하나의 IP에서 여러 개의 애플리케이션과 통신 가능

예:

- 웹 서버 (HTTP) → 80번 포트
- 데이터베이스 서버 → 3306번 포트
- SSH 서버 → 22번 포트

---

# DNS (Domain Name System)

### DNS가 무엇의 줄임말인가?

Domain Name System

### IP는 변하기 쉽고 외우기 어려운데 이러한 점을 어떻게 해결하나?

도메인 네임을 사용하여 IP 주소를 기억할 필요 없이 웹사이트에 접속 가능

예:

- `www.google.com` → `142.250.190.46`

DNS 서버는 도메인 이름을 IP 주소로 변환해 줌

---

# URI (Uniform Resource Identifier)

### URL (Uniform Resource Locator)

웹 상의 자원의 위치를 나타냄

### Query Parameter, Query String

- Query Parameter: `?key=value&key2=value2` 형태로 데이터를 전달
- 예: `https://example.com/search?q=fintech&lang=en`
- `q=fintech`, `lang=en` → Query Parameter

### URN (Uniform Resource Name)

자원의 위치와 관계없이 식별 가능한 고유한 이름

예: ISBN(도서 번호), DOI(논문 식별자)

---

# 웹 브라우저 요청 흐름

1. **웹 브라우저가 요청 패킷 전달**
    - 사용자가 URL을 입력하고 요청을 보냄
2. **웹 서버에 요청 패킷 도착**
    - DNS를 통해 IP를 찾고, 해당 서버로 HTTP 요청을 전달
3. **웹 서버는 TCP/IP 패킷 내부 정보 확인**
    - HTTP 요청을 분석하여 어떤 리소스를 요청했는지 확인
4. **웹 서버는 요청을 보고 HTTP 응답 메시지를 생성**
    - 응답 헤더 및 바디 구성
    - `Content-Type`을 설정하여 클라이언트가 응답을 올바르게 해석할 수 있도록 함
5. **웹 브라우저가 HTTP 응답 메시지를 받고 해당 데이터를 렌더링**
    - HTML, CSS, JavaScript를 실행하여 화면을 표시

---

# HTTP/1.1 버전

### HTTP/1.1 버전이 무엇이길래 중요한가?

1. **Persistent Connection 지원** - 여러 개의 요청을 하나의 TCP 연결로 처리
2. **Host 헤더 필수** - 가상 호스팅을 지원하여 같은 IP에서 여러 도메인을 운영 가능
3. **Chunked Transfer Encoding** - 데이터를 부분적으로 나누어 전송 가능

---

# HTTP 특징

### 클라이언트-서버 구조

클라이언트가 요청을 보내고, 서버가 응답을 반환하는 구조

### Stateful, Stateless 차이

- **Stateful** - 서버가 클라이언트의 상태를 유지
- **Stateless** - 서버가 클라이언트의 상태를 유지하지 않음

### Stateless 한계

- 매 요청마다 인증 정보가 필요함
- 대용량 트래픽 처리에 어려움

### 서버 개발자들이 어려워하는 업무

- 동시 대량 요청이 발생하는 이벤트 처리
    - 선착순 이벤트
    - 명절 KTX 예약
    - 학과 수업 등록
    - 저녁 6:00 선착순 치킨 이벤트

### 비연결성

요청과 응답이 끝나면 연결을 종료

### 한계

- 매 요청마다 새로운 연결을 맺어야 하므로 성능 저하 발생

---

# HTTP 메시지 구조

### 시작 라인

1. **Request Line (요청 메시지)**
    - `HTTP 메서드 요청 대상 HTTP 버전`
    - 예: `GET /index.html HTTP/1.1`
2. **Response Line (응답 메시지)**
    - `HTTP 버전 상태 코드 이유 문구`
    - 예: `HTTP/1.1 200 OK`